#!/bin/bash
#
# perform CRUD operations in s3 interactively
#
# @params
# Globals
#   ${action_command}: default to upload, determines what operation(upload/download/delete/bucket) to take
#   ${operation_cmd}: default to cp, determine what cmd to use in s3 command(cp/mv/sync)
#   ${bucket}: bucket name
#   ${target_bucket}: target bucket name
#   ${s3_path}: s3 bucket path, root would be bucket name, bucket/path
#   ${target_s3_path}: when action_command=bucket, the target s3 location for file transfer
#   ${local_path}: local file or directory path for download or upload, need to be set by -P flag
#   ${recursive}: determine if the -r flag is set for recursive operation
#   ${hidden}: determine if the local file search should include hidden files
#   ${search_from_root}: determine if the find/fd should search from root
#   ${expires_in}: time to live the url generated by presign action
#   ${wild_pattern}: exclude/include certain file based on pattern
# Arguments
#   command: action command
#   ${opt}: option flag

# import helper scripts
mydir="${0%/*}"
source "${mydir}"/shfaws/confirm.sh
source "${mydir}"/shfaws/search_file.sh
source "${mydir}"/shfaws/s3/helper/get_bucket.sh
source "${mydir}"/shfaws/s3/helper/get_bucket_path.sh
source "${mydir}"/shfaws/s3/upload_file_s3.sh
source "${mydir}"/shfaws/s3/delete_file_s3.sh
source "${mydir}"/shfaws/s3/download_file_s3.sh
source "${mydir}"/shfaws/s3/transfer_file_s3.sh
source "${mydir}"/shfaws/s3/presign_url_s3.sh
source "${mydir}"/shfaws/s3/usage.sh

# disable glob as globing will cause issue with wild_pattern
set -o noglob

# default operation_cmd
operation_cmd='cp'
action_command=''
local_path=''
recursive=''
hidden=''
search_from_root=''
expires_in=''
wild_pattern=''

# process the command to use
# shift to remove the command from the args
case "$1" in
  upload)
    action_command='upload'
    shift;;
  download)
    action_command='download'
    shift;;
  delete)
    action_command='delete'
    shift;;
  bucket)
    action_command='bucket'
    shift;;
  presign)
    action_command='presign'
    shift;;
  ls)
    action_command='ls'
    shift;;
esac

while getopts ":p:hrmHP:Rst:e:i:" opt
do
  case "${opt}" in
    p)
      # -p expect a path bucket/path
      if [[ -z "${s3_path}" ]]; then
        s3_path="${OPTARG}"
      elif [[ -z "${target_s3_path}" ]]; then
        target_s3_path="${OPTARG}"
      fi
      ;;
    P)
      # specify a local file path
      local_path="${OPTARG}";;
    r)
      # set recursive flag
      recursive='true';;
    R)
      # search local file/path from root
      search_from_root='true';;
    m)
      # mv instead of cp
      operation_cmd='mv';;
    H)
      hidden='true';;
    h)
      usage "${action_command}"
      exit 0;;
    s)
      operation_cmd='sync'
      recursive='true';;
    t)
      expires_in="${OPTARG}";;
    i)
      if [[ -z "${wild_pattern}" ]]; then
        wild_pattern="--include ${OPTARG}"
      else
        wild_pattern="${wild_pattern} --include ${OPTARG}"
      fi
      ;;
    e)
      if [[ -z "${wild_pattern}" ]]; then
        wild_pattern="--exclude ${OPTARG}"
      else
        wild_pattern="${wild_pattern} --exclude ${OPTARG}"
      fi
      ;;
    *)
      echo "Invalid option: ${OPTARG}" >&2
      usage "${action_command}"
      exit 1;;
  esac
done

# if no action commands detected, display fzf menu about all available commands
# show their help message on selection
if [[ -z "${action_command}" ]]; then
  echo "No action command detected"
  echo "Below are the available supported commands"
  available_commands=(upload download delete bucket presign ls)
  help_commands="$(printf '%s\n' "${available_commands[@]}" | fzf --preview "${mydir}/s3 {} -h")"
  usage "$help_commands"
  exit 0
fi

# remove recursive flag for ls command
[[ "${action_command}" == 'ls' ]] && recursive=''

# remove the recursive flag for presign url operation, as we don't want to display folder in s3
if [[ "${action_command}" == 'presign' ]]; then
  recursive=''
  # set to zero to inform the presign_url_s3 script to use the default timeout which is 3600s
  [[ -z "${expires_in}" ]] && expires_in=0
fi

# get the bucket path before any operation
if [[ -z "${s3_path}" ]]; then
  echo "Select a bucket"
  # get bucekt name
  bucket="$(get_bucket)"
  [[ -z "${bucket}" ]] && echo "No bucket selected" && exit 1
  [[ ! -z "${action_command}" ]] && echo "Select a path"
  # get subfolders in the bucket or root
  s3_path="$(get_bucket_path "${bucket}" "${action_command}" "${recursive}")"
  [[ -z "${s3_path}" ]] && echo "No option/path selected" && exit 1
fi

# process operation type and call different scripts
if [[ "${action_command}" == 'upload' ]]; then
  upload_file_s3 "${operation_cmd}" "${s3_path}" "${recursive}" "${hidden}" "${search_from_root}" "${local_path}" "${wild_pattern}"
elif [[ "${action_command}" == 'download' ]]; then
  download_file_s3 "${operation_cmd}" "${s3_path}" "${recursive}" "${hidden}" "${search_from_root}" "${local_path}" "${wild_pattern}"
elif [[ "${action_command}" == 'delete' ]]; then
  delete_file_s3  "${s3_path}" "${recursive}" "${wild_pattern}"
elif [[ "${action_command}" == 'bucket' ]]; then
  if [[ -z "${target_s3_path}" ]]; then
    echo "Select a target bucket for file transfer between buckets"
    # select a second bucket
    target_bucket=$(get_bucket)
    [[ -z "${target_bucket}" ]] && echo "Target bucket not selected" && exit 1
    echo "Select a path where the file should be ${operation_cmd}"
    # select second bucket path
    target_s3_path=$(get_bucket_path "${target_bucket}" "${action_command}" 'true')
    [[ -z "${target_s3_path}" ]] && echo "Target path not specified" && exit 1
  fi
  transfer_file_s3 "${operation_cmd}" "${s3_path}" "${target_s3_path}" "${recursive}" "${wild_pattern}"
elif [[ "${action_command}" == 'presign' ]]; then
  presign_url_s3 "${s3_path}" "${expires_in}"
elif [ "${action_command}" == 'ls' ]; then
  # just print the path if no operation type set
  echo "s3://${s3_path}"
  exit 0
fi
